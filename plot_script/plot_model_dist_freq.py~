#!/usr/bin/env python3

import obspy, obspy.signal, os.path, time, glob, shutil, scipy, subprocess, sys
from obspy import read, UTCDateTime
from obspy.core import Stream, Trace, event

import obspy.signal
import matplotlib.pyplot as plt
import numpy as np
from obspy.io.xseed import Parser
from subprocess import call
import matplotlib.colors as colors
import matplotlib.cm as cm
import shutil
import os
import os.path


event = sys.argv[1]
component = 'BAT'



## Plot synthetics
synthetics = ''
#while (synthetics != 'y' and synthetics != 'n'):
#    synthetics = input('Do you want to plot synthetics (y/n)?')
#    if (synthetics == 'y'):
#        syn = True
#    if (synthetics == 'n'):
#        syn = False
syn = False

real = True  # plot real data
color = False # color by measured travel times
switch_yaxis = True


## Frequencies for filter
#fmin = 1/20  #Hz
#fmax = 1/10   #Hz

dir = '/raid3/zl382/Data/Synthetics/' + event + '/'
#dir = '/raid2/sc845/ULVZ/Synthetics/OUT_ULVZ10km_1s_mtp500kmPICKLES/'
#dirdump = dir + 'Dump'
#if not os.path.exists(dirdump):
#    os.makedirs(dirdump)
    
seislist = sorted(glob.glob(dir + '*PICKLE'))
norm = None
azis = []
dists = []

seis = read(dir+'SYN_90.PICKLE',format='PICKLE')
seistoplot = seis.select(channel = component)[0]

norm = np.max(seistoplot.times())

fmin = [1/30, 1/20, 1/10, 1/5]  
fmax = [1/10, 1/5, 1, 1]

plot_row = 1
plot_column = 4

plt.figure(figsize=(11.69,8.27))
for i in range(plot_column):
    if i == 0:
        ax0=plt.subplot(plot_row, plot_column, i+1)
    else:
        plt.subplot(plot_row, plot_column, i+1)
    print('i=',i)

    
        # Loop through seismograms
    for s in range(0,len(seislist),1):
        
        #print(s, '/', len(seislist))
        seis = read(seislist[s],format='PICKLE') # Read seismogram
        dists.append(seis[0].stats['dist'])# List all distances
        #    azis.append(seis[0].stats['az'])      # List all azimuths
        #    print('Azimuth: ', seis[0].stats['az'],'Distance: ',seis[0].stats['dist'])
        seistoplot = seis.select(channel = component)[0]
        
        # plot synthetics
        if syn:
            seissyn = seis.select(channel = component)[0]
        
        # Plot seismograms
        #print(seis[0].stats.traveltimes['Sdiff'])
        
        Phase = ['Sdiff', 'S']
        for x in range (0,2):
            if  seis[0].stats.traveltimes[Phase[x]]!=None:
                phase = Phase[x]
        
        # Filter data
        
        seistoplot.filter('highpass',freq=fmin[i],corners=2,zerophase=True)
        seistoplot.filter('lowpass',freq=fmax[i],corners=2,zerophase=True)
        if syn:
            seissyn.filter('highpass', freq=fmin[i],corners=2,zerophase=True)
            seissyn.filter('lowpass',freq=fmax[i],corners=2,zerophase=True)
        
        # Time shift to shift data to reference time
        tshift = 0#seis[0].stats['starttime'] - UTCDateTime(seis[0].stats['eventtime'])
        
        #print('max',np.max(seistoplot.times()))
        
        if real:
            norm = None
            if norm == None:
                norm = 1.* np.max(abs(seistoplot.data)) / 2.7
                
        
        # Plot with real distances
        #    plt.plot(seistoplot.times() + tshift - seis[0].stats.traveltimes[phase], seistoplot.data / norm+ (seis[0].stats['dist']),'k')
        # Plot with round distances
        try:
            plt.plot(seistoplot.times() + tshift - seis[0].stats.traveltimes[phase], seistoplot.data / norm + np.round(seis[0].stats['dist']),'k')
        except:
            continue
        
        if syn:
            if norm == None:
                norm = 20.*np.max(seissyn.data)
                plt.plot(seissyn.times() - seis[0].stats.traveltimes[phase],seissyn.data/norm + np.round(seis[0].stats['dist']),'b')
                plt.xlim([-20,200])
        
        # Plot travel time predictions
        for k in seis[0].stats.traveltimes.keys():
            if seis[0].stats.traveltimes[k] != None:
                plt.plot(seis[0].stats.traveltimes[k] - seis[0].stats.traveltimes[phase], np.round(seis[0].stats['dist']),'g', marker ='o', markersize=4)
        
        # Plot the station name
        s_name = os.path.splitext(os.path.split(seislist[s])[1])[0]
        #plt.text(200,seis[0].stats['dist'],s_name, fontsize = 8)


    if i == 0:
        plt.ylabel('Distance (deg)')
        
    plt.title('frequency range [%i s - %i s]' % (1/fmax[i], 1/fmin[i]),fontsize=12)
    plt.xlabel('Time around predicted arrival (s)')
    plt.xlim([-20, 60])
    plt.ylim([140, 90])
    if switch_yaxis:
        plt.gca().invert_yaxis()
plt.suptitle('Model ' + event)  

plt.show()
